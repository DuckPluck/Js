// Чуть подробнее про контекст и прототипирование
// Рассмотрим группу метод функции 
// .bind() - сменить контекст для this
// .call() и .apply() - выполнить функцию с смененным контекстом this

// Создадим объект персоны с функцией:

const person = {
    name: 'Daniil',
    age: '23',
    loginfo: function(job, phone) {                           // Эта запись - function() {} - эквивалента стрелочной функции, только с несколькими строчками
        console.group(`${this.name} info:`)       // console.group() позволяет объединить все логи, вложенные в блок до console.groupEnd()
        console.log(`Name is ${this.name}`)
        console.log(`Age is ${this.age}`)
        console.log(`Job is ${job}`)              // Эти параметры мы принимаем извне, так что без .this
        console.log(`Phone is ${phone}`)
        console.groupEnd()
    }
}

// person.loginfo()

// Теперь создадим новую персону - Карину, чтобы вызвать для нее чужую функцию loginfo()

const karina = {
    name: 'Karina',
    age: '22'
}



// Мы обращаемся к функции loginfo, затем байндим ее контекст на Карину

// person.loginfo.bind(karina)()                   // Метод bind() только возвращает функцию, чтобы вызвать ее и сразу выполнить нужно добавить скобки в конце 
                                                // (можно опустить назваие функции, когда оно совпадает с названием инициализации и упростить запись)



// Создадим новую функцию на основе прошлой для демонстрации передачи аргументов в bind()
// const fnKarinaInfoLog = person.loginfo.bind(karina)

// Сразу ее вызываем с аргументами:
// fnKarinaInfoLog('Frontend', '8-999-123-12-12')

// Также для упрощения записи можно прописать аргументы прямо в метот .bind() после имени персоны
// const fnKarinaInfoLog = person.loginfo.bind(karina, 'Frontend', '8-999-123-12-12')
// fnKarinaInfoLog()

// Ну и соответственно можно сразу инициировать и выполнить ее:
// const fnKarinaInfoLog = person.loginfo.bind(karina, 'Frontend', '8-999-123-12-12')()



// Метод .call() позволяет только вызывать, без инициации (то есть обратиться через него у фунцкции нельзя)
// person.loginfo.call(karina, 'Frontend', '8-999-123-12-12')

// Тоже самое делает метод .apply(), только аргументы перечисляются в массиве
// person.loginfo.apply(karina, ['Frontend', '8-999-123-12-12'])


// Таким образом можно вызывать чужие функции объектов

// Если развивать эту тему, то можно сделать так, чтобы вшить функцию в прототип объекта. Тогда ее не нужно будет импортировать, передавать в нее массив,
// она уже будет доступна для любого объекта нужного типа.

// Создадим функцию, которая выполняет опр. логику для массива
const array = [1,2,3,4,5]

// function multBy(arr, n) {
//     return arr.map((i) => i * n)
// }

// console.log(multBy(array, 20))

// Теперь нам нужно каждый раз ее импортировать и передавать в нее новый массив.
// Чтобы избежать этого, мы вошьем функцию в прототип массива:

Array.prototype.multBy = function(n) {
        return this.map((i) => i * n)       // Тут this будет указывать на массив, для которого мы применяем функци
}

console.log(array.multBy(20))